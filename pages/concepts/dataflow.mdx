# ReadySet Internals

The heart of ReadySet is a query engine. This query engine, however, is very different from those of 
traditional relational databases in that it is based on **partially-stateful, streaming data flow**. 

What's that? Let's break it down. First, we'll take a look at the basics of **stateful, streaming dataflow**, then 
in a later section we'll consider how to improve memory overhead through **partial state**. 

## Streaming dataflow 
The basic premise of [streaming dataflow](https://en.wikipedia.org/wiki/Stream_processing) is that a series 
of operations is applied to each element of a stream (a given a sequence of data). 

#### Stream

The stream that ReadySet deals with is the sequence of data changes made to your underlying database due to writes. 
ReadySet receives this stream as input by registering itself as a [read replica of your primary database](https://dev.mysql.com/doc/internals/en/replication.html). 
The data change stream primarily consists of **inserts of new records** to the base tables and **updates of 
existing records** in the base tables.  

#### Operations 

ReadySet applies SQL operations over this data change stream to compute the results of the SQL queries you want to cache. When ReadySet receives a new SQL query, it first creates a query plan, which consists of the ordered sequence of transformations over the data in the base tables that needs to be applied to compute the correct query result. ReadySet then instantiates a long-lived **data flow graph** that actually executes the operations in the query plan over the incoming data stream. 

The entry points of ReadySet's data flow graph are referred to as **base table nodes**, which represent the application base tables 
and funnel in incoming data changes to the rest of the graph. 

Below the base table nodes are the **internal nodes** that compute SQL operators (e.g. joins, aggregates, projections, and filters)
over the incoming stream of data changes. These nodes are stateful in that they track the results of these operations, keeping 
them up to date in real-time. Whenever the results of the operation change due to the incoming data changes, these internal nodes 
emit the updated results and propagate them downstream in the graph.

Since these internal nodes are connected together based on a query plan, the leaf nodes of the graph (referred to as **reader nodes**) 
cache the final query results, and all non-leaf nodes effectively cache intermediate state.  

![High Level](/high-level-graph.png)

## Putting it all together

As writes are applied to your database, the resulting data changes are immediately replicated to ReadySet. ReadySet incrementally 
updates its cached query results to reflect these changes, thus replacing any hand-written cache eviction logic. When using ReadySet,
you just write traditional SQL queries, and ReadySet will keep the results up-to-date for you. 



## Example: Workload
To illustrate these concepts, we will walk through an example of using ReadySet for a news forum application inspired by HackerNews.

### Schema
First we define two tables to keep track of HackerNews stories and votes. 

```CREATE TABLE stories (id int, author text, title text, url text); ```

```CREATE TABLE votes (user int, story_id int);``` 

### Query 

Next, we'll write a query that computes the vote count for each story and joins the 
vote counts with other story metadata such as the author, title, and ID.  

```
SELECT id, author, title, url, vcount 
FROM stories 
JOIN (SELECT story_id, COUNT(*) AS vcount 
            FROM votes GROUP BY story_id)  
AS VoteCount 
ON VoteCount.story_id = stories.id WHERE stories.id = ?; 
``` 

## Example: Caching with ReadySet

Traditional databases would compute the results of this query from scratch every time it was issued. ReadySet takes a 
different approach and instead precomputes and incrementally maintains the results of this query for commonly read keys.
To accomplish this, ReadySet creates a streaming dataflow graph, as described in the previous section. At a high level, the 
data flow graph would look as follows:

![Vote Count](/prepared-to-high-level.png)

Under the hood, here's what some of the internal state might look like for this graph. 

![Vote Count Specific](/votequeryspecific.png)

Now, we’ll take a look at what happens when the data changes. Let’s say that we add a record to the Votes table to 
reflect the fact that Justin voted for the story with ID `2`. This update would first be applied to the Votes base table at 
the root of the graph, and then be propagated through the graph, updating all children nodes along that way. 
The figure below shows the modified state at each node as the result of this write.

![Write Prop](/WriteProp.gif)

When performing a read (i.e. executing the prepared statement), we're essentially just doing a key-value lookup for the parameter 
value on the relevant column of the reader node. 

![prepread](/executeread.png)
![prepread2](/executeread2.png)

In this case, we're doing a lookup for key `2` on the `ID` column of the reader node. These lookups are blazingly fast, since reader 
nodes are lock-free, in-memory data structures. 
